"use strict";
class MUDocPreloader
{
    get s ()
    {
        return {
            class: {
                element: 'loading',
                block: 'loading__block',
                animation: 'loading__animation'
            }
        }
    }

    /**
     * @type {HTMLElement[]}
     */
    static #elements = [];

    /**
     * @type {MUDocPreloader[]}
     */
    static #handlers = [];

    /**
     * @type {HTMLElement}
     */
    #element;

    /**
     * @type {HTMLDivElement}
     */
    #block;

    /**
     * @type {HTMLDivElement}
     */
    #animation;

    #loading = false;

    static set (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            return this.#handlers[index];
        }

        let handler = this.get(element);

        if (!handler) {
            handler = new this(element);

            this.#elements.push(element);
            this.#handlers.push(handler);
        }

        return handler.start();
    }

    /**
     * @param {HTMLElement} element
     * @returns {MUDocPreloader|null}
     */
    static get (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            return this.#handlers[index];
        }

        return null;
    }

    static destroy (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            this.#elements.splice(index, 1);
            this.#handlers.splice(index, 1);
        }
    }

    constructor (element)
    {
        this.#element = element;
    }

    start ()
    {
        if (!this.#loading) {
            this.#loading = true;
            this.#loadingClassState(true);
            this.#loadingHTMLState(true);
        }

        return this;
    }

    stop (destroy = false)
    {
        if (this.#loading) {
            this.#loading = false;
            this.#loadingClassState(false);
            this.#loadingHTMLState(false);
        }
        if (destroy) {
            this.destroy();
        }
    }

    destroy ()
    {
        this.stop();
        this.constructor.destroy(this.#element);
        this.#element   = undefined;
        this.#block     = undefined;
        this.#animation = undefined;
    }

    #loadingClassState (statement)
    {
        if (statement) {
            this.#element.classList.add(this.s.class.element);
        } else {
            this.#element.classList.remove(this.s.class.element);
        }
    }

    #loadingHTMLState (statement)
    {
        if (statement) {
            this.#createHTML();
            this.#element.append(this.#block);
        } else {
            this.#block.remove();
        }
    }

    #createHTML ()
    {
        this.#block     = document.createElement('div');
        this.#animation = document.createElement('div');

        this.#block.append(this.#animation);

        this.#block.classList.add(this.s.class.block);
        this.#animation.classList.add(this.s.class.animation);
    }
}
class MUDoc
{
    static #initialized = false;

    /**
     * @type {function[]}
     */
    static #on_ready = [];

    static #is_ready = false;

    static #on_resize = [];

    static #resize_timestamp = 0;

    static get is_ready ()
    {
        return this.#is_ready || document.readyState === 'complete';
    }

    /**
     * @param {function} callback
     */
    static ready (callback)
    {
        this.#initialize();
        if (!this.#is_ready) {
            this.#on_ready.push(callback);
        } else {
            callback();
        }
    }

    static #initialize ()
    {
        if (!this.#initialized) {
            this.#initialized = true;
            if (!this.is_ready) {
                this.event(window, 'load', this.#complete.bind(this), true);
            } else {
                this.#complete();
            }
            this.event(window, 'resize', this.#evaluateResize.bind(this), true);
        }
    }

    static #complete ()
    {
        if (!this.#is_ready) {
            this.#is_ready = true;
            this.#callEach(this.#on_ready);
            this.#on_ready = undefined;
        }
    }

    static #callEach (callbacks, ...parameters)
    {
        callbacks.forEach(callback => callback(...parameters));
    }

    /**
     * @param {function} callback
     */
    static resize (callback)
    {
        this.#initialize();
        this.#on_resize.push(callback);
    }

    static #evaluateResize (event)
    {
        if (this.#on_resize.length > 0) {
            this.#callEach(this.#on_resize, event);
            this.#resize_timestamp = event.timeStamp;
        }
    }

    /**
     * @param {NodeListOf<EventTarget>|EventTarget[]|EventTarget|string} target
     * @param {string[]|string} type
     * @param {function} callback
     * @param {boolean} passive
     */
    static event (
        target,
        type,
        callback,
        passive = false
    )
    {
        if (typeof target === 'string') {
            target = document.querySelectorAll(target);
        }
        if (target instanceof NodeList || target instanceof Array) {
            target.forEach(
                event_target => this.event(event_target, type, callback, passive)
            );
        } else if (type instanceof Array) {
            type.forEach(
                t => this.event(target, t, callback, passive)
            );
        } else if (target) {
            target.addEventListener(type, callback, passive ? {passive: true} : null)
        }
    }

    /**
     * An alias for event() method with `click` event type.
     *
     * @param {NodeListOf<EventTarget>|EventTarget[]|EventTarget|string} target
     * @param {function} callback
     * @param {boolean} passive
     */
    static onclick (
        target,
        callback,
        passive = false
    )
    {
        this.event(target, 'click', callback, passive);
    }

    static loading (element, complete = false)
    {
        if (complete) {
            MUDocPreloader.get(element)?.destroy();
        } else {
            MUDocPreloader.set(element);
        }
    }
}
class MUCanvasPoint
{
    #x = 0;

    #y = 0;

    get x ()
    {
        return this.#x;
    }

    get y ()
    {
        return this.#y;
    }

    /**
     * @param {MUCanvasPoint|number} x_position
     * @param {MUCanvasPoint|number} y_position
     * @returns {MUCanvasPoint}
     */
    pos (x_position, y_position = undefined)
    {
        this.posX(x_position)
            .posY(typeof y_position === 'undefined' ? x_position : y_position);

        return this;
    }

    posX (x_position)
    {
        if (x_position instanceof MUCanvasPoint) {
            this.#x = x_position.x;
        } else {
            this.#x = x_position;
        }

        return this;
    }

    posY (y_position)
    {
        if (y_position instanceof MUCanvasPoint) {
            this.#y = y_position.y;
        } else {
            this.#y = y_position;
        }

        return this;
    }
}
class MUCanvasDummy extends MUCanvasPoint
{
    /**
     * Clockwise rotation (degrees).
     *
     * @type {number}
     */
    #angle = 0;

    /**
     * Get or set clockwise rotation angle.
     *
     * @param {number} degrees (optional) Set new rotation angle.
     */
    angle (degrees = undefined)
    {
        if (typeof degrees === 'undefined') {
            return this.#angle;
        }

        this.#angle = Math.max(0, Math.min(360, degrees));

        return this;
    }

    /**
     * @param {CanvasRenderingContext2D} context HTML canvas 2D context API
     *
     * @returns {void|never}
     */
    render (context)
    {
        // This is abstract method that must be implemented
        throw new Error("Method MUCanvasShape.render() must be implemented.");
    }
}
class MUCanvasShapeBorder
{
    #width = 0;

    #color = '#ffffff';

    width (value = undefined) {
        if (typeof value === 'undefined') {
            return this.#width;
        }

        this.#width = Math.max(0, value);

        return this;
    }

    color (value = undefined) {
        if (typeof value === 'undefined') {
            return this.#color;
        }

        this.#color = value;

        return this;
    }
}
class MUCanvasShape extends MUCanvasDummy
{
    #color = '#ffffff';

    /**
     * @type {MUCanvasShapeBorder}
     */
    #border;

    static get circle ()
    {
        return new MUCanvasShapeCircle();
    }

    static get rectangle ()
    {
        return new MUCanvasShapeRectangle();
    }

    /**
     * @returns {MUCanvasShapeBorder}
     */
    get border ()
    {
        if (!this.#border) {
            this.#border = new MUCanvasShapeBorder();
        }

        return this.#border;
    }

    fill (color = undefined)
    {
        if (typeof color === 'undefined') {
            return this.#color;
        }

        this.#color = color;

        return this;
    }

    /**
     * @param {CanvasRenderingContext2D} context HTML canvas 2D context API
     *
     * @returns {void|never}
     */
    render (context)
    {
        // This is abstract method that must be implemented
        throw new Error("Method MUCanvasShape.render() must be implemented.");
    }
}
class MUCanvasShapeCircle extends MUCanvasShape
{
    #radius = 0;

    get diameter ()
    {
        return this.#radius * 2;
    }

    radius (value = undefined) {
        if (typeof value === 'undefined') {
            return this.#radius;
        }

        this.#radius = Math.max(value, 0);

        return this;
    }

    render (context)
    {
        context.beginPath();
        context.arc(this.x, this.y, this.radius(), 0, 2 * Math.PI);

        if (this.border.width()) {
            context.lineWidth = this.border.width();
            context.strokeStyle = this.border.color();
            context.stroke();
        }
    }
}
class MUCanvasShapeRectangle extends MUCanvasShape
{}
class MUCanvasSize
{
    /**
     * @type {HTMLCanvasElement}
     */
    #canvas;

    #grid = {
        min:    10,
        width:  24,
        height: 24,
        locked: false
    };

    #available_height = 0;

    #available_width = 0;

    #cell_size;

    get width ()
    {
        return this.#canvas.width;
    }

    get height ()
    {
        return this.#canvas.height;
    }

    get grid_width ()
    {
        return this.#grid.width;
    }

    get grid_height ()
    {
        return this.#grid.height;
    }

    get parent_styles ()
    {
        return getComputedStyle(this.#canvas.parentElement);
    }

    get is_square ()
    {
        return this.#grid.width === this.#grid.height;
    }

    get cell_size ()
    {
        if (typeof this.#cell_size === 'undefined') {
            this.#cell_size = this.#canvas.width / this.#grid.width;
        }

        return this.#cell_size;
    }

    /**
     * @param {HTMLCanvasElement} canvas
     */
    constructor (canvas)
    {
        this.#canvas = canvas;
    }

    update ()
    {
        this.#calculateFreeSpace();
        this.#updateSize();
        this.#cell_size = undefined;

        return this;
    }

    /**
     * @returns {void}
     */
    #calculateFreeSpace ()
    {
        let styles = this.parent_styles;

        this.#available_width = parseFloat(styles.width)
            - parseFloat(styles.borderLeftWidth)
            - parseFloat(styles.borderRightWidth)
            - parseFloat(styles.paddingLeft)
            - parseFloat(styles.paddingRight);

        this.#available_height = window.innerHeight - 80;
    }

    #updateSize ()
    {
        if (this.is_square) {
            this.#canvas.width = this.#canvas.height = Math.min(this.#available_width, this.#available_height);

            return;
        }
        let target_height = this.#available_width / this.#grid.width * this.#grid.height;
        if (target_height > this.#available_height) {
            this.#canvas.height = this.#available_height;
            this.#canvas.width = this.#available_height / this.#grid.height * this.#grid.width;
        } else {
            this.#canvas.width = this.#available_width;
            this.#canvas.height = target_height;
        }
    }

    grid (width, height = undefined)
    {
        if (!this.#grid.locked) {
            this.#grid.width  = Math.max(width, this.#grid.min);
            this.#grid.height = Math.max(height || width, this.#grid.min);
            this.update();
        }

        return this;
    }
}

class MUCanvas
{
    /**
     * @type {HTMLCanvasElement}
     */
    #canvas;

    #initialized = false;

    /**
     * @type {MUCanvasSize}
     */
    #size;

    /**
     * @type {{MUCanvasShape}}
     */
    #shapes = {};

    /**
     * @returns {MUCanvasSize}
     */
    get size ()
    {
        if (!this.#size) {
            this.#size = new MUCanvasSize(this.#canvas);
        }

        return this.#size;
    }

    /**
     * @returns {CanvasRenderingContext2D}
     */
    get context ()
    {
        return this.#canvas.getContext('2d');
    }

    /**
     * @param {HTMLCanvasElement} canvas
     */
    constructor (canvas)
    {
        this.#canvas = canvas;
    }

    initialize ()
    {
        if (!this.#initialized) {
            this.size.update();
            MUDoc.resize(this.size.update.bind(this.size));
            this.#initialized = true;
        }
    }

    clear ()
    {
        this.context.clearRect(0, 0, this.#canvas.width, this.#canvas.height);
    }

    draw ()
    {
        Object.keys(this.#shapes).forEach(
            key => this.#shapes[key].render(this.context)
        );
    }

    redraw ()
    {
        this.clear();
        this.draw();
    }

    /**
     *
     * @param key
     * @param shape
     * @returns {MUCanvas|MUCanvasShape|undefined}
     */
    shape (key, shape = undefined)
    {
        if (shape) {
            this.#shapes[key] = shape;

            return this;
        }

        return this.#shapes[key];
    }
}
class MUCoreGameSnakeSegment extends MUCanvasDummy
{
    get STATE ()
    {
        return {
            FIRST:  -1,
            MIDDLE: 0,
            LAST:   1
        }
    }

    #size;

    #middle = this.STATE.MIDDLE;

    get is_first ()
    {
        return this.#middle === this.STATE.FIRST;
    }

    get is_middle ()
    {
        return this.#middle === this.STATE.MIDDLE;
    }

    get is_last ()
    {
        return this.#middle === this.STATE.LAST;
    }

    setFirst ()
    {
        this.#middle = this.STATE.FIRST;
    }

    setMiddle ()
    {
        this.#middle = this.STATE.MIDDLE;
    }

    setLast ()
    {
        this.#middle = this.STATE.LAST;
    }

    size (size = undefined)
    {
        if (typeof size === 'undefined') {
            return this.#size;
        }

        this.#size = Math.max(0, size);

        return this;
    }

    render (context)
    {
        let size = MUCore.canvas.size.cell_size;

        let x = size * (this.x - 1) + 1,
            y = size * (this.y - 1) + 1;

        context.fillStyle = '#9b4335';
        context.fillRect(x, y, size - 2, size - 2);
    }
}
class MUCoreGameSnake
{
    get s ()
    {
        return {
            size: 3
        };
    }

    get DIR ()
    {
        return {
            NONE:  0,
            UP:    1,
            RIGHT: 2,
            DOWN:  -1,
            LEFT:  -2
        }
    }

    #direction;

    #size;

    /**
     * @type {MUCoreGameSnakeSegment[]}
     */
    #segments;

    setInitialState ()
    {
        this.#size      = this.s.size;
        this.#direction = this.DIR.UP;
        this.#segments  = [];
        this.#createSegments();
    }

    #createSegments ()
    {
        let start = new MUCanvasPoint(),
            x_reminder = MUCore.canvas.size.grid_width % 2,
            y_reminder = MUCore.canvas.size.grid_height % 2;

        start.pos(
            (MUCore.canvas.size.grid_width - x_reminder) / 2 + x_reminder,
            (MUCore.canvas.size.grid_height - y_reminder) / 2 + y_reminder - 1,
        );

        for (let i = 0; i < this.#size; ++i) {
            this.#createSegment(start);
            this.#move(start, this.#direction * -1);
        }
    }

    #createSegment (inherit)
    {
        let segment = new MUCoreGameSnakeSegment();

        segment.pos(inherit);
        this.#segments.push(segment);

        MUCore.canvas.shape('seg' + this.#segments.length, segment);
    }

    /**
     * @param {MUCanvasPoint} point
     * @param {number} direction
     */
    #move (point, direction)
    {
        switch (direction)
        {
            case this.DIR.UP:
                point.posY(point.y - 1);
                break;
            case this.DIR.DOWN:
                point.posY(point.y + 1);
                break;
            case this.DIR.LEFT:
                point.posX(point.x - 1);
                break;
            case this.DIR.RIGHT:
                point.posX(point.x + 1);
                break;
        }

        this.#moveLimits(point, direction);
    }

    /**
     * @param {MUCanvasPoint} point
     * @param {number} direction
     */
    #moveLimits (point, direction)
    {
        let min = 1,
            max,
            current,
            handler;

        if (this.#isVertical(direction)) {
            max = MUCore.canvas.size.grid_height;
            current = point.y;
            handler = point.posY.bind(point);
        } else if (this.#isHorizontal(direction)) {
            max = MUCore.canvas.size.grid_width;
            current = point.x;
            handler = point.posX.bind(point);
        } else {
            return;
        }

        if (current > max) {
            handler(min);
        } else if (current < min) {
            handler(max);
        }
    }

    #isVertical (direction = undefined)
    {
        if (typeof direction === 'undefined') {
            direction = this.#direction;
        }

        return direction & 1;
    }

    #isHorizontal (direction = undefined)
    {
        if (typeof direction === 'undefined') {
            direction = this.#direction;
        }

        return direction && !this.#isVertical(direction);
    }

    move (grow = false)
    {
        let last = this.#segments.length - 1;

        if (grow) {
            this.#createSegment(this.#segments[last]);
        }

        for (let i = last; i >= 0; --i) {
            if (i) {
                this.#segments[i].pos(this.#segments[i - 1])
            } else {
                this.#move(this.#segments[i], this.#direction);
            }
        }
    }
}
class MUCoreGameScore
{
    get s ()
    {
        return {
            selector: {
                input: '#board-score-value'
            }
        };
    }

    /**
     * @type {MUCoreGame}
     */
    #game;

    /**
     * @type {HTMLInputElement}
     */
    #input;

    #value = 0;

    get value ()
    {
        return this.#value;
    }

    constructor (game)
    {
        this.#game = game;
    }

    initialize ()
    {
        this.#input = this.#game.board.querySelector(this.s.selector.input);
    }

    reset ()
    {
        this.#value = 0;
        this.#update();
    }

    #update ()
    {
        this.#input.value = '' + this.#value;
    }
}
class MUCoreGameControl
{
    get s ()
    {
        return {
            selector: {
                action: '#board-action',
                size: '.board__control_size'
            },
            speed: {
                max: 12,
                min: 1
            },
            action: {
                state: {
                    stop: 'Play',
                    play: 'Pause',
                    pause: 'Resume'
                }
            },
            sizes: [
                [33, 25],
                [33, 33],
                [49, 33],
            ],
            default_size: 1,
            class: {
                active: 'active'
            }
        }
    }

    get STATUS ()
    {
        return {
            STOP:  0,
            PLAY:  1,
            PAUSE: 2
        }
    }

    #initialized = false;

    /**
     * @type {MUCoreGame}
     */
    #game;

    /**
     * @type {HTMLButtonElement}
     */
    #action;

    /**
     * @type {number}
     */
    #speed = 1;

    /**
     * @type {number}
     */
    #status;

    /**
     * @type {NodeListOf<HTMLButtonElement>}
     */
    #size_controls;

    #selected_size;

    /**
     * @type {function[]}
     */
    #on_resize = [];

    /**
     * @returns {HTMLButtonElement}
     */
    get action ()
    {
        return this.#action;
    }

    /**
     * @returns {number}
     */
    get speed ()
    {
        return this.#speed;
    }

    /**
     * @returns {boolean}
     */
    get speed_up ()
    {
        if (this.#speed < this.s.speed.max) {
            --this.#speed;

            return true;
        }

        return false;
    }

    /**
     * @returns {boolean}
     */
    get speed_down ()
    {
        if (this.#speed > this.s.speed.min) {
            --this.#speed;

            return true;
        }

        return false;
    }

    /**
     * @returns {number}
     */
    get status ()
    {
        return this.#status;
    }

    /**
     * @returns {boolean}
     */
    get is_play ()
    {
        return this.#status === this.STATUS.PLAY;
    }

    /**
     * @returns {boolean}
     */
    get is_stop ()
    {
        return this.#status === this.STATUS.STOP;
    }

    /**
     * @returns {boolean}
     */
    get is_pause ()
    {
        return this.#status === this.STATUS.PAUSE;
    }

    /**
     * @returns {NodeListOf<HTMLButtonElement>}
     */
    get sizes ()
    {
        return this.#size_controls;
    }

    get selected_size ()
    {
        return this.s.sizes[this.#selected_size];
    }

    constructor (game)
    {
        this.#game = game;
    }

    initialize ()
    {
        if (!this.#initialized) {
            this.#action        = this.#game.board.querySelector(this.s.selector.action);
            this.#size_controls = this.#game.board.querySelectorAll(this.s.selector.size);
            this.#size_controls.forEach(
                (control, i) =>
                {
                    let size = this.s.sizes[i];

                    if (!size) {
                        throw new Error("Unknown game board size: " + control.innerText);
                    }

                    control.innerText = size[0] + 'x' + size[1];

                    MUDoc.onclick(
                        control,
                        () => this.#selectSize(i)
                    );
                }
            )
            this.#selectSize(this.s.default_size);
            this.#initialized = true;
        }
    }

    setStatePlay ()
    {
        this.#status           = this.STATUS.PLAY;
        this.#action.innerText = this.s.action.state.play;
        this.#sizeDisabled(true);
    }

    setStatePause ()
    {
        this.#status           = this.STATUS.PAUSE;
        this.#action.innerText = this.s.action.state.pause;
    }

    setStateStop ()
    {
        this.#status           = this.STATUS.STOP;
        this.#action.innerText = this.s.action.state.stop;
    }

    setInitialState ()
    {
        this.#status           = this.STATUS.STOP;
        this.#action.innerText = this.s.action.state.stop;
        this.#action.disabled  = false;
        this.#sizeDisabled(false);
    }

    #sizeDisabled (statement)
    {
        this.#size_controls.forEach(
            control => control.disabled = statement
        );
    }

    #selectSize (index)
    {
        if (this.#selected_size !== index) {
            this.#selected_size = index;
            this.#size_controls.forEach(
                (control, i) =>
                {
                    if (i === index) {
                        control.classList.add(this.s.class.active);
                    } else {
                        control.classList.remove(this.s.class.active);
                    }
                }
            );
            this.#resizeEvaluate();
        }
    }

    onresize (callback)
    {
        this.#on_resize.push(callback);
    }

    #resizeEvaluate ()
    {
        this.#on_resize.forEach(
            callback =>
            {
                if (typeof callback === 'function') {
                    callback(...this.selected_size);
                }
            }
        );
    }
}
class MUCoreGame
{
    /**
     * @type {HTMLElement}
     */
    #board;

    /**
     * @type {MUCoreGameControl}
     */
    #control;

    /**
     * @type {MUCoreGameSnake}
     */
    #snake;

    /**
     * @type {MUCoreGameScore}
     */
    #score;

    get board ()
    {
        return this.#board;
    }

    /**
     * @param {HTMLElement} board
     */
    constructor (board)
    {
        this.#board = board;
    }

    initialize ()
    {
        this.#loading(true);
        this.#initializeControls();
        this.#initializeEvents();
        this.#viewStartScreen();
        this.#loading(false);
    }

    #initializeControls ()
    {
        this.#control = new MUCoreGameControl(this);
        this.#control.initialize();

        this.#score = new MUCoreGameScore(this);
        this.#score.initialize();
    }

    #initializeEvents ()
    {
        MUDoc.onclick(
            this.#control.action,
            event => this.#start(event)
        );

        this.#control.onresize(
            (width, height) => MUCore.canvas.size.grid(width, height)
        );
    }

    #loading (statement)
    {
        MUDoc.loading(this.#board, !statement);
    }

    #start (event)
    {
        event.preventDefault();

        if (this.#control.is_play) {
            this.pause();
        } else {
            this.start();
        }
    }

    start ()
    {
        if (this.#control.is_stop) {
            this.#startNew();
        } else if (this.#control.is_pause) {
            this.resume()
        }
    }

    pause ()
    {
        if (this.#control.is_play) {
            this.#control.setStatePause();
        }
    }

    resume ()
    {
        if (this.#control.is_pause) {
            this.#control.setStatePlay();
        }
    }

    stop ()
    {
        if (!this.#control.is_stop) {
            this.#control.setStateStop();

            // TODO: remove control events handler
        }
    }

    #startNew ()
    {
        this.#control.setStatePlay();
        this.#score.reset();
        this.#setSnakeInitialState();
        this.#createTicker();

        // TODO: initialize selected speed

        // TODO: create control events handlers

        // TODO: create ticks
    }

    #viewStartScreen ()
    {
        // TODO: render first screen
        MUCore.canvas.size.grid(...this.#control.selected_size);
        this.#control.setInitialState();
    }

    #setSnakeInitialState ()
    {
        this.#snake = new MUCoreGameSnake();
        this.#snake.setInitialState();
    }

    #createTicker ()
    {
        setInterval(
            () =>
            {
                this.#snake.move();
                MUCore.canvas.redraw();
            },
            500
        );
    }
}
class MUCore
{
    /**
     * Default configuration parameters
     */
    static get c ()
    {
        return {
            id: {
                board:  'board',
                canvas: 'board-canvas'
            }
        };
    }

    /**
     * Game handler instance
     *
     * @type {MUCoreGame}
     */
    static #game;

    /**
     * @returns {MUCoreGame}
     */
    static get game ()
    {
        if (!this.#game) {
            this.#game = new MUCoreGame(document.getElementById(this.c.id.board));
        }

        return this.#game;
    }

    /**
     * Canvas interface handler instance
     *
     * @type {MUCanvas}
     */
    static #canvas;

    /**
     * @returns {MUCanvas}
     */
    static get canvas ()
    {
        if (!this.#canvas) {
            this.#canvas = new MUCanvas(document.getElementById(this.c.id.canvas));
        }

        return this.#canvas;
    }

    static initialize ()
    {
        // TODO: initialize main canvas and controls handlers
        this.canvas.initialize();
        this.game.initialize();
    }
}
MUDoc.ready(
    () => MUCore.initialize()
)
