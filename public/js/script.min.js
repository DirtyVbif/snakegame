"use strict";
class MUCanvas
{
    /**
     * @type {HTMLCanvasElement}
     */
    #canvas;

    #initialized = false;

    /**
     * @type {MUCanvasSize}
     */
    #size;

    /**
     * @returns {MUCanvasSize}
     */
    get size ()
    {
        if (!this.#size) {
            this.#size = new MUCanvasSize(this.#canvas);
        }

        return this.#size;
    }

    /**
     * @param {HTMLCanvasElement} canvas
     */
    constructor (canvas)
    {
        this.#canvas = canvas;
    }

    initialize ()
    {
        if (!this.#initialized) {
            this.size.update();
            MUDoc.resize(this.size.update.bind(this.size));
            this.#initialized = true;
        }
    }
}
class MUCore
{
    /**
     * Default configuration parameters
     */
    static get c ()
    {
        return {
            id: {
                board:  'board',
                canvas: 'board-canvas'
            }
        };
    }

    /**
     * Game handler instance
     *
     * @type {MUCoreGame}
     */
    static #game;

    /**
     * @returns {MUCoreGame}
     */
    static get game ()
    {
        if (!this.#game) {
            this.#game = new MUCoreGame(document.getElementById(this.c.id.board));
        }

        return this.#game;
    }

    /**
     * Canvas interface handler instance
     *
     * @type {MUCanvas}
     */
    static #canvas;

    /**
     * @returns {MUCanvas}
     */
    static get canvas ()
    {
        if (!this.#canvas) {
            this.#canvas = new MUCanvas(document.getElementById(this.c.id.canvas));
        }

        return this.#canvas;
    }

    static initialize ()
    {
        // TODO: initialize main canvas and controls handlers
        this.canvas.initialize();
        this.game.initialize();
    }
}
class MUDoc
{
    static #initialized = false;

    /**
     * @type {function[]}
     */
    static #on_ready = [];

    static #is_ready = false;

    static #on_resize = [];

    static #resize_timestamp = 0;

    static get is_ready ()
    {
        return this.#is_ready || document.readyState === 'complete';
    }

    /**
     * @param {function} callback
     */
    static ready (callback)
    {
        this.#initialize();
        if (!this.#is_ready) {
            this.#on_ready.push(callback);
        } else {
            callback();
        }
    }

    static #initialize ()
    {
        if (!this.#initialized) {
            this.#initialized = true;
            if (!this.is_ready) {
                this.event(window, 'load', this.#complete.bind(this), true);
            } else {
                this.#complete();
            }
            this.event(window, 'resize', this.#evaluateResize.bind(this), true);
        }
    }

    static #complete ()
    {
        if (!this.#is_ready) {
            this.#is_ready = true;
            this.#callEach(this.#on_ready);
            this.#on_ready = undefined;
        }
    }

    static #callEach (callbacks, ...parameters)
    {
        callbacks.forEach(callback => callback(...parameters));
    }

    /**
     * @param {function} callback
     */
    static resize (callback)
    {
        this.#initialize();
        this.#on_resize.push(callback);
    }

    static #evaluateResize (event)
    {
        if (this.#on_resize.length > 0) {
            this.#callEach(this.#on_resize, event);
            this.#resize_timestamp = event.timeStamp;
        }
    }

    /**
     * @param {NodeListOf<EventTarget>|EventTarget[]|EventTarget|string} target
     * @param {string[]|string} type
     * @param {function} callback
     * @param {boolean} passive
     */
    static event (
        target,
        type,
        callback,
        passive = false
    )
    {
        if (typeof target === 'string') {
            target = document.querySelectorAll(target);
        }
        if (target instanceof NodeList || target instanceof Array) {
            target.forEach(
                event_target => this.event(event_target, type, callback, passive)
            );
        } else if (type instanceof Array) {
            type.forEach(
                t => this.event(target, t, callback, passive)
            );
        } else if (target) {
            target.addEventListener(type, callback, passive ? {passive: true} : null)
        }
    }

    /**
     * An alias for event() method with `click` event type.
     *
     * @param {NodeListOf<EventTarget>|EventTarget[]|EventTarget|string} target
     * @param {function} callback
     * @param {boolean} passive
     */
    static onclick (
        target,
        callback,
        passive = false
    )
    {
        this.event(target, 'click', callback, passive);
    }

    static loading (element, complete = false)
    {
        if (complete) {
            MUDocPreloader.get(element)?.destroy();
        } else {
            MUDocPreloader.set(element);
        }
    }
}
class MUCanvasSize
{
    /**
     * @type {HTMLCanvasElement}
     */
    #canvas;

    #step = 100;

    #grid = {
        min: 10,
        width: 24,
        height: 24,
        locked: false
    };

    #parent_resized_width = 0;

    get #parent_width_changed ()
    {
        let width   = parseFloat(this.parent_styles.width),
            changed = width !== this.#parent_resized_width;

        this.#parent_resized_width = width;

        return changed;
    }

    get parent_styles ()
    {
        return getComputedStyle(this.#canvas.parentElement);
    }

    /**
     * @param {HTMLCanvasElement} canvas
     */
    constructor (canvas)
    {
        this.#canvas = canvas;
    }

    update ()
    {
        if (this.#parent_width_changed) {
            let free_space = this.#calculateFreeSpace(),
                steps      = Math.floor(free_space / this.#step),
                size       = this.#step * steps;

            this.#setWidth(size);
        }
    }

    /**
     * @returns {number}
     */
    #calculateFreeSpace ()
    {
        let styles = this.parent_styles;

        return parseFloat(styles.width)
            - parseFloat(styles.borderLeftWidth)
            - parseFloat(styles.borderRightWidth)
            - parseFloat(styles.paddingLeft)
            - parseFloat(styles.paddingRight);
    }

    #setWidth (width)
    {
        this.#canvas.width = width;
        this.#updateHeight();
    }

    grid (width, height = undefined)
    {
        if (!this.#grid.locked) {
            this.#grid.width  = Math.max(width, this.#grid.min);
            this.#grid.height = Math.max(height || width, this.#grid.min);
            this.#updateHeight();
        }

        return this;
    }

    #updateHeight ()
    {
        this.#canvas.height = (this.#grid.width === this.#grid.height)
            ? this.#canvas.width
            : this.#canvas.width / this.#grid.width * this.#grid.height
    }
}

class MUCoreGame
{
    get STATUS ()
    {
        return {
            STOP:  0,
            PLAY:  1,
            PAUSE: 2
        }
    }

    /**
     * @type {HTMLElement}
     */
    #board;

    /**
     * @type {HTMLButtonElement}
     */
    #action_start;

    #status = this.STATUS.STOP;

    /**
     * @type {MUCoreGameSnake}
     */
    #snake;

    #speed = 1;

    #score = 0;

    get is_play ()
    {
        return this.#status === this.STATUS.PLAY;
    }

    get is_stop ()
    {
        return this.#status === this.STATUS.STOP;
    }

    get is_pause ()
    {
        return this.#status === this.STATUS.PAUSE;
    }

    /**
     * @param {HTMLElement} board
     */
    constructor (board)
    {
        this.#board = board;
    }

    initialize ()
    {
        this.#initializeControls();
        this.#initializeEvents();
    }

    #initializeControls ()
    {
        this.#action_start = this.#board.querySelector('#board-play');
    }

    #initializeEvents ()
    {
        MUDoc.onclick(
            this.#action_start,
            event => this.#start(event)
        );
    }

    #start (event)
    {
        event.preventDefault();

        if (this.is_play) {
            this.pause();
        } else {
            this.start();
        }
    }

    start ()
    {
        if (this.is_stop) {
            this.#startNew();
        } else if (this.is_pause) {
            this.resume()
        }
    }

    pause ()
    {
        if (!this.is_play) {
            return;
        }
        this.#status = this.STATUS.PAUSE;
    }

    resume ()
    {
        this.#status = this.STATUS.PLAY;
    }

    stop ()
    {
        if (this.is_stop) {
            return;
        }
        this.#status = this.STATUS.STOP;

        // TODO: remove control events handler
    }

    #startNew ()
    {
        this.#status = this.STATUS.PLAY;
        this.#score = 0;
        this.#snake = new MUCoreGameSnake();

        // TODO: initialize selected speed

        // TODO: create control events handlers

        // TODO: create ticks
    }
}
class MUDocPreloader
{
    get s ()
    {
        return {
            class: {
                element: 'loading',
                block: 'loading__block',
                animation: 'loading__animation'
            }
        }
    }

    /**
     * @type {HTMLElement[]}
     */
    static #elements = [];

    /**
     * @type {MUDocPreloader[]}
     */
    static #handlers = [];

    /**
     * @type {HTMLElement}
     */
    #element;

    /**
     * @type {HTMLDivElement}
     */
    #block;

    /**
     * @type {HTMLDivElement}
     */
    #animation;

    #loading = false;

    static set (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            return this.#handlers[index];
        }

        let handler = this.get(element);

        if (!handler) {
            handler = new this(element);

            this.#elements.push(element);
            this.#handlers.push(handler);
        }

        return handler.start();
    }

    /**
     * @param {HTMLElement} element
     * @returns {MUDocPreloader|null}
     */
    static get (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            return this.#handlers[index];
        }

        return null;
    }

    static destroy (element)
    {
        let index = this.#elements.indexOf(element);
        if (index > -1) {
            this.#elements.splice(index, 1);
            this.#handlers.splice(index, 1);
        }
    }

    constructor (element)
    {
        this.#element = element;
    }

    start ()
    {
        if (!this.#loading) {
            this.#loading = true;
            this.#loadingClassState(true);
            this.#loadingHTMLState(true);
        }

        return this;
    }

    stop (destroy = false)
    {
        if (this.#loading) {
            this.#loading = false;
            this.#loadingClassState(false);
            this.#loadingHTMLState(false);
        }
        if (destroy) {
            this.destroy();
        }
    }

    destroy ()
    {
        this.stop();
        this.constructor.destroy(this.#element);
        this.#element   = undefined;
        this.#block     = undefined;
        this.#animation = undefined;
    }

    #loadingClassState (statement)
    {
        if (statement) {
            this.#element.classList.add(this.s.class.element);
        } else {
            this.#element.classList.remove(this.s.class.element);
        }
    }

    #loadingHTMLState (statement)
    {
        if (statement) {
            this.#createHTML();
            this.#element.append(this.#block);
        } else {
            this.#block.remove();
        }
    }

    #createHTML ()
    {
        this.#block     = document.createElement('div');
        this.#animation = document.createElement('div');

        this.#block.append(this.#animation);

        this.#block.classList.add(this.s.class.block);
        this.#animation.classList.add(this.s.class.animation);
    }
}
class MUCoreGameSnake
{
    get DIR ()
    {
        return {
            NONE:  0,
            UP:    1,
            RIGHT: 2,
            DOWN:  -1,
            LEFT:  -2
        }
    }

    #goto = this.DIR.NONE;

    #direction = this.DIR.UP;

    #size = 3;
}
MUDoc.ready(
    () => MUCore.initialize()
)
